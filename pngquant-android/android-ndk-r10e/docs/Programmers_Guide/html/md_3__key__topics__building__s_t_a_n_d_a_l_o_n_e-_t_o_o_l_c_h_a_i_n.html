<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>NDK Programmer&#39;s Guide: Standalone Toolchain</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NDK Programmer&#39;s Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_3__key__topics__building__s_t_a_n_d_a_l_o_n_e-_t_o_o_l_c_h_a_i_n.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Standalone Toolchain </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>It is now possible to use the toolchains provided with the Android NDK as standalone compilers. This can be useful if you already have your own build system, and only need to ability to invoke the cross-compiler to add support to Android for it.</p>
<p>A typical use case if invoking the 'configure' script of an open-source library that expects a cross-compiler in the CC environment variable.</p>
<p>This document explains how to do that:</p>
<h2>Selecting your toolchain</h2>
<p>Before anything else, you need to decide whether your standalone toolchain is going to target ARM-based devices, x86-based, or MIPS-based one. Each architecture corresponds to a different toolchain name. For example:</p>
<ul>
<li>arm-linux-androideabi-4.8 =&gt; targeting ARM-based Android devices</li>
<li>x86-4.8 =&gt; targeting x86-based Android devices</li>
<li>mipsel-linux-android-4.8 =&gt; targeting MIPS-based Android devices</li>
</ul>
<h2>Selecting your sysroot</h2>
<p>The second thing you need to know is which Android native API level you want to target. Each one of them provides a different various APIs, which are documented under doc/STABLE-APIS.html, and correspond to the sub-directories of $NDK/platforms.</p>
<p>This allows you to define the path to your 'sysroot', a GCC term for a directory containing the system headers and libraries of your target. Usually, this will be something like: </p>
<pre class="fragment">    SYSROOT=$NDK/platforms/android-&lt;level&gt;/arch-&lt;arch&gt;/
</pre><p>Where &lt;level&gt; is the API level number, and &lt;arch&gt; is the architecture ("arm", "x86", and "mips" are the supported values). For example, if you're targeting Android 2.2 (a.k.a. Froyo), you would use: </p>
<pre class="fragment">    SYSROOT=$NDK/platforms/android-8/arch-arm
</pre><p>IMPORTANT: Note that X86 and MIPS architectures are only supported at android-9 and later.</p>
<h2>Invoking the compiler (the hard way)</h2>
<p>Invoke the compiler using the &ndash;sysroot option to indicate where the system files for the platform you're targeting are located. For example, do: </p>
<pre class="fragment">    export CC="$NDK/toolchains/&lt;name&gt;/prebuilt/&lt;system&gt;/bin/&lt;prefix&gt;gcc --sysroot=$SYSROOT"
    $CC -o foo.o -c foo.c
</pre><p>Where &lt;name&gt; is the toolchain's name, &lt;system&gt; is the host tag for your system, and &lt;prefix&gt; is a toolchain-specific prefix. For example, if you are on Linux using the NDK r5 toolchain, you would use: </p>
<pre class="fragment">    export CC="$NDK/toolchains/arm-linux-androideabi-4.8/prebuilt/linux-x86/bin/arm-linux-androideabi-gcc --sysroot=$SYSROOT"
</pre><p>As you can see, this is rather verbose, but it works!</p>
<p>IMPORTANT NOTE:</p>
<p>Using the NDK toolchain directly has a serious limitation: You won't be able to use any C++ STL (STLport, libc++, or the GNU libstdc++) with it. Also no exceptions and no RTTI.</p>
<p>For clang, you need to add correct "-target" for given architecture, and add "-gcc-toolchain" to path of GNU-based toolchain for "as" and "ld", eg.</p>
<ol type="1">
<li>Add "-target armv7-none-linux-androideabi" for armeabi-v7a, "-target armv5te-none-linux-androideabi" for armeabi, "-target i686-none-linux-android" for x86, "-target mipsel-none-linux-android" for mips, and</li>
<li>Add "-gcc-toolchain $NDK/toolchains/arm-linux-androideabi-4.8/prebuilt/linux-x86_64"</li>
</ol>
<h2>Invoking the compiler (the easy way)</h2>
<p>The NDK allows you to create a "customized" toolchain installation to make life easier. For example, consider the following command: </p>
<pre class="fragment">    $NDK/build/tools/make-standalone-toolchain.sh --platform=android-5 --install-dir=/tmp/my-android-toolchain
</pre><p>This will create a directory named /tmp/my-android-toolchain containing a copy of the android-5/arch-arm sysroot, and of the toolchain binaries.</p>
<p>Note that by default, the 32-bit ARM-based GCC 4.8 toolchain will be selected by the script. Use the '&ndash;arch=x86' option to specify the x86 GCC 4.8, or add '&ndash;arch=mips' option to specify the MIPS GCC 4.8, or alternatively '&ndash;toolchain=&lt;name&gt;'. For example: </p>
<pre class="fragment">    --toolchain=x86-4.8                    # select x86 GCC 4.8 compiler
    --toolchain=arm-linux-androideabi-4.9  # select ARM GCC 4.9 compiler
    --toolchain=mipsel-linux-android-4.8   # select MIPS GCC 4.8 compiler, same as --arch=mips
</pre><p>If you wish, add '&ndash;llvm-version=3.3' to also copy clang/llvm 3.3, or use &ndash;toolchain with '-clang3.3' suffix. For example: </p>
<pre class="fragment">    --toolchain=arm-linux-androideabi-clang3.3  # same as --arch=arm --llvm-version=3.3
</pre><p>You may specify &ndash;system=linux-x86_64 on 64-bit Linux or &ndash;system=darwin-x86_64 on 64-bit MacOSX to make 64-bit host toolchain instead of the 32-bit one (default). See IV of NDK-BUILD.html</p>
<p>You may specify &ndash;stl=stlport to copy libstlport instead of libgnustl. Note that to link against the shared library, you will have to explicitely use -lstlport_shared in this case, just like you need to use -lgnustl_shared for the GNU libstdc++ case. Static linking doesn't require anything special.</p>
<p>Likewise you may specify &ndash;stl=libc++ to copy LLVM libc++ headers and libraries. Note that to link against the shared library, you will have to explicitely use -lc++_shared.</p>
<p>You can later use it directly with something like: </p>
<pre class="fragment">    export PATH=/tmp/my-android-toolchain/bin:$PATH
    export CC=arm-linux-androideabi-gcc   # or export CC=clang
    export CXX=arm-linux-androideabi-g++  # or export CXX=clang++
</pre><p>Note that without the &ndash;install-dir option, make-standalone-toolchain.sh will create a tarball in /tmp/ndk/&lt;toolchain-name&gt;.tar.bz2. This allows you to archive and redistribute the binaries easily.</p>
<p>Another important benefit is that this standalone toolchain will contain a working copy of a C++ STL library, with working exceptions and RTTI support.</p>
<p>Use &ndash;help for more options and details.</p>
<p>IMPORTANT<br/>
 The toolchain binaries do not depend or contain host-specific paths, in other words, they can be installed in any location, or even moved if you need to.</p>
<p>NOTE<br/>
 You can still use the &ndash;sysroot option with the new toolchain, but it is now simply optional!</p>
<h2>About Clang</h2>
<p>It is possible to also install Clang binaries in the standalone installation by using the &ndash;llvm-version=&lt;version&gt; option, where &lt;version&gt; is a LLVM/Clang version number (e.g. <code>3.2</code> or <code>3.3</code>). E.g.: </p>
<pre class="fragment">    build/tools/make-standalone-toolchain.sh \
        --install-dir=/tmp/mydir \
        --toolchain=arm-linux-androideabi-4.7 \
        --llvm-version=3.3
</pre><p>Note that Clang binaries are copied in addition to the GCC ones, because they rely on the same assembler, linker, headers, libraries and C++ STL implementation.</p>
<p>This also installs two scripts under &lt;install-dir&gt;/bin/ named '<code>clang</code>' and '<code>clang++</code>' which invoke the real clang binary with default target architecture flags. In other words, they should "just work" and you should be able to use them in your own builds by setting CC and CXX environment variables to point to them.</p>
<p>The rest of this section gives more detail about how these work, in case you encounter some unexpected problems.</p>
<p>For example, in an ARM standalone installation built with <code>--llvm-version=3.3</code>, <code>clang</code> is a one-liner that looks like this on Unix: </p>
<pre class="fragment">    `dirname $0`/clang31 -target armv5te-none-linux-androideabi "$@"
</pre><p>And <code>clang++</code> invokes <code>clang++31</code> in the same way.</p>
<p>Note that for ARM, <code>clang</code> will change target based on the presence of subsequent option "`-march=armv7-a`" and/or "`-mthumb`". ie.</p>
<ol type="1">
<li>With "`-march=armv7-a`", -target becomes <code>armv7-none-linux-androideabi</code>.</li>
<li>With "`-mthumb`", -target becomes <code>thumb-none-linux-androideabi</code>.</li>
<li>With both, -target becomes <code>thumbv7-none-linux-androideabi</code>.</li>
</ol>
<p>You may override with your own -target if you wish.</p>
<p>There is no need for "-gcc-toolchain" because clang locates "as" and "ld" in predefined relative location in standalone package.</p>
<p>Extra efforts have been made to make clang/clang++ easier drop-in replacements for gcc/g++ in Makefile. When in doubt, use the following common techniques to check:</p>
<ol type="1">
<li>Add option "`-v`" to dump commands compiler driver issues</li>
<li>Add option "`-###`" to dump command line options, including those implicitly predefined.</li>
<li>Use "`-x c` `/dev/null` `-dM` `-E`" to dump predefined preprocessor definitions</li>
<li>Add option "`-save-temps`" and compare the preprocessed files <code>*.i</code> or <code>*.ii</code></li>
</ol>
<p>See <a href="http://clang.llvm.org/">http://clang.llvm.org/</a> , especially the GCC compatibility section.</p>
<h2>ABI Compatibility</h2>
<p>The machine code generated by the ARM toolchain should be compatible with the official Android 'armeabi' ABI (see docs/CPU-ARCH-ABIS.html) by default.</p>
<p>It is recommended to use the -mthumb compiler flag to force the generation of 16-bit Thumb-1 instructions (the default being 32-bit ARM ones).</p>
<p>If you want to target the 'armeabi-v7a' ABI, you will need ensure that the following flags are being used: </p>
<pre class="fragment">    CFLAGS='-march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16'
</pre><p>Note: The first flag enables Thumb-2 instructions, and the second one enables H/W FPU instructions while ensuring that floating-point parameters are passed in core registers, which is critical for ABI compatibility. Do <em>not</em> use these flags separately before NDK r9b!</p>
<p>If you want to use Neon instructions, you will need to change the -mfpu compiler flag: </p>
<pre class="fragment">    CFLAGS='-march=armv7-a -mfloat-abi=softfp -mfpu=neon'
</pre><p>Note that this forces the use of VFPv3-D32, as per the ARM specification.</p>
<p>Also, make sure the following two flags are provided to linker: </p>
<pre class="fragment">    LDFLAGS='-march=armv7-a -Wl,--fix-cortex-a8'
</pre><p>Note: The first flag instructs linker to pick libgcc.a, libgcov.a and crt*.o tailored for armv7-a. The 2nd flag is <em>required</em> to route around a CPU bug in some Cortex-A8 implementations:</p>
<p>Since NDK r9b, all Android native APIs taking or returning double/float has <b>attribute</b>((pcs("aapcs"))) for ARM. It's possible to compile user code in -mhard-float (which implies -mfloat-abi=hard) and still link with Android native APIs which follow softfp ABI. Please see tests/device/hard-float/jni/Android.mk for details.</p>
<p>If you want to use NEON intrinsics on x86 they can be translated to the native x86 SSE ones using special C/C++ language header with the same name as standard arm neon intrinsics header "arm_neon.h".</p>
<p>By default x86 ABI supports SIMD up to SSSE3 and the header covers ~93% NEON functions (1869 of total 2009).</p>
<p>To learn more about it, see <a href="./md_3__key__topics__c_p_u__support__c_p_u-_x86.html">x86</a>.</p>
<p>If none of the above makes sense to you, it's probably better not to use the standalone toolchain, and stick to the NDK build system instead, which will handle all the details for you.</p>
<p>You don't have to use any specific compiler flag when targeting the MIPS ABI.</p>
<h2>Warnings and Limitations</h2>
<h3>Windows support</h3>
<p>The Windows binaries do <em>not</em> depend on Cygwin. The good news is that they are thus faster, the bad news is that they do not understand the Cygwin path specification like <code>/cygdrive/c/foo/bar</code> (instead of <code>C:/foo/bar</code>).</p>
<p>The NDK build system ensures that all paths passed to the compiler from Cygwin are automatically translated, and deals with other horrors for you. If you have a custom build system, you may need to deal with the problem yourself.</p>
<p>NOTE: There is no plan to support Cygwin / MSys at the moment, but contributions are welcome. Contact the android-ndk forum for details.</p>
<h3><code>wchar_t</code> support</h3>
<p>As documented, the Android platform did not really support wchar_t until Android 2.3. What this means in practical terms is that:</p>
<ul>
<li>If you target platform android-9 or higher, the size of wchar_t is 4 bytes, and most wide-char functions are available in the C library (with the exception of multi-byte encoding/decoding functions and wsprintf/wsscanf).</li>
<li>If you target any prior API level, the size of wchar_t will be 1 byte and none of the wide-char functions will work anyway.</li>
</ul>
<p>We recommend any developer to get rid of any dependencies on the wchar_t type and switch to better representations. The support provided in Android is only there to help you migrate existing code.</p>
<h3>Exceptions, RTTI, and STL</h3>
<p>The toolchain binaries <em>do</em> support C++ exceptions and RTTI by default. They are enabled by default, so use -fno-exceptions and -fno-rtti if you want to disable them when building sources with them (e.g. to generate smaller machine code).</p>
<p>NOTE: If you use the GNU libstdc++, you will need to explicitly link with libsupc++ if you use these features. To do this, use -lsupc++ when linking binaries, as in: </p>
<pre class="fragment">      arm-linux-androideabi-g++ .... -lsupc++
</pre><p>This is not needed when using the STLport or libc++ library.</p>
<h3>C++ STL support</h3>
<p>The standalone toolchain includes a copy of a C++ Standard Template Library implementation, either the GNU libstdc++, STLport, or libc++, determined by your use of the &ndash;stl=&lt;name&gt; option described previously. To use this STL implementation, you however need to link your project with the proper library:</p>
<ul>
<li><p class="startli">Use -lstdc++ to link against the <em>static</em> library version of any implementation. This ensures that all required C++ STL code is included into your final binary. This is ideal if you are only generating a <b>single</b> shared library or executable.</p>
<p class="startli">This is the recommended way to do it.</p>
</li>
<li><p class="startli">Use -lgnustl_shared to link against the <em>shared</em> library version of GNU libstdc++. If you use this option, you need to ensure that <code>libgnustl_shared.so</code> is also copied to your device for your code to load properly. The file is at: </p>
<pre class="fragment">$TOOLCHAIN/arm-linux-androideabi/lib/  for ARM toolchains.
$TOOLCHAIN/i686-linux-android/lib/     for x86 ones.
$TOOLCHAIN/mipsel-linux-android/lib/   for MIPS toolchains.
</pre><p class="startli">IMPORTANT: The GNU libstdc++ is licensed under the <b>GPLv3</b> with a linking exception. See the following URL for details:</p>
</li>
</ul>
<blockquote class="doxtable">
<p><a href="http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt01ch01s02.html">http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt01ch01s02.html</a></p>
<p></p>
</blockquote>
<blockquote class="doxtable">
<p>If you cannot comply with its requirements, i.e. you cannot redistribute</p>
<p></p>
</blockquote>
<p>the shared library, do not use it in your project.</p>
<ul>
<li>Use -lstlport_shared to link against the <em>shared</em> library version of STLport. If you use this option, you need to ensure that <code>libstlport_shared.so</code> is also copied to your device for your code to load properly. They are found at the same locations than those for <code>gnustl_shared</code>.</li>
</ul>
<p><b>VERY</b> <b>IMPORTANT</b> <b>NOTE</b>: If your project contains <em>multiple</em> shared libraries or executables, you <b>must</b> link against a shared library STL implementation. Otherwise, some global variables won't be defined uniquely, which can result in all kind of weird behaviour at runtime, like crashes, exceptions not being caught properly, and more surprises.</p>
<p>The reason the shared version of the libraries is not simply called <code>libstdc++.so</code> is not called libstdc++.so is because this would conflict at runtime with the system's own minimal C++ runtime, which is <code>/system/lib/libstdc++.so</code>. This enforces a new name for the GNU ELF library. This is not a problem for the static library. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jun 25 2014 00:51:19 for NDK Programmer&#39;s Guide by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
