<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>NDK Programmer&#39;s Guide: x86</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NDK Programmer&#39;s Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_3__key__topics__c_p_u__support__c_p_u-_x86.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">x86 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>Android NDK r6 added support for the '<code>x86</code>' ABI, that allows native code to run on Android-based devices running on CPUs supporting the IA-32 instruction set.</p>
<p>The Android x86 ABI itself is fully specified in docs/CPU-ARCH-ABIS.html.</p>
<h2>Overview</h2>
<p>Generating x86 machine code is simple: just add 'x86' to your APP_ABI definition in your Application.mk file, for example: </p>
<pre class="fragment">    APP_ABI := armeabi armeabi-v7a x86
</pre><p>Alternatively, since NDK r7, you can use: </p>
<pre class="fragment">    APP_ABI := all
</pre><p>will generate machine code for all supported ABIs with this NDK. Doing so will ensure that your application package contains libraries for all target ABIs. Note that this has an impact on package size, since each ABI will correspond to its own set of native libraries built from the same sources.</p>
<p>The default ABI is still '<code>armeabi</code>', if unspecified in your project.</p>
<p>As you would expect, generated libraries will go into <code>$PROJECT/libs/x86/</code>, and will be embedded into your .apk under <code>/lib/x86/</code>.</p>
<p>And just like other ABIs, the Android package manager will extract these libraries on a <em>compatible</em> x86-based device automatically at install time, to put them under &lt;dataPath&gt;/lib, where &lt;dataPath&gt; is the application's private data directory.</p>
<p>Similarly, the Google Play server is capable of filtering applications based on the native libraries they embed and your device's target CPU.</p>
<p>Debugging with ndk-gdb should work exactly as described under docs/NDK-GDB.html.</p>
<h2>ARM NEON intrinsics support</h2>
<p>The solution is shaped as C/C++ language header with the same name as standard ARM NEON intrinsics header "arm_neon.h" and is available in all NDK x86 toolchains. It translates NEON intrinsics to native x86 SSE ones.</p>
<p>By default SSE up to SSSE3 is used for porting ARM NEON to Intel SSE.</p>
<p>Current solution covers by default ~93% NEON functions (1869 of total 2009).</p>
<p>The solution</p>
<ul>
<li>Redefines ARM NEON 128 bit vectors as the corresponding x86 SIMD data.</li>
<li>Redefines some functions from ARM NEON to Intel SSE if 1:1 correspondence exists.</li>
<li>Implements some ARM NEON functions using Intel SIMD if the performance effective implementation is possible.</li>
<li>Implements some of the remaining NEON functions using the serial solution and issuing the corresponding "low performance" compiler warning.</li>
</ul>
<h3>Known differences with ARM version:</h3>
<p>There are few corner cases where x86 implementation produces different results comparing to native execution on ARM. It's been found on <a href="https://gitorious.org/arm-neon-tests/arm-neon-tests">NEON tests</a> with total passrate close to 100%. Though these cases are expected to be rare please see below for a complete list of such incompatibilities:</p>
<ul>
<li><code>VRECPS/VRECPSQ</code><br/>
  If one of the operands is +/- infinity and the second is +/- 0.0 then
  <ul>
    <li>On ARM CPUs result element equal to 2.0 will be returned. To learn more about it, see <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489h/CIHDIACI.html">here</a>.</li>
    <li>On x86 CPUs QNaN Indefinite will be returned. To learn more about it, see Volume 1 Appendix E chapter E.4.2.2 <a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf">here</a>.</li>
  </ul>
</li>
<li><code>VRSQRTS/VRSQRTSQ</code><br/>
  If one of the operands is +/- infinity and the second is +/- 0.0 then
  <ul>
    <li>On ARM CPUs result element equal to 1.5 will be returned. To learn more about it, see <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489h/CIHDIACI.html">here</a>.</li>
    <li>On x86 CPUs QNaN Indefinite will be returned. To learn more about it, see Volume 1 Appendix E chapter E.4.2.2 <a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf">here</a>.</li>
  </ul>
</li>
<li><code>VMAX/VMAXQ</code><br/>
  If one of the operands is NaN or both are +/- 0.0 then
  <ul>
    <li>On ARM CPUs floating-point maximum works as follows:
      <ul>
        <li>max(+0.0, -0.0) = +0.0.</li>
        <li>If any input is a NaN, the corresponding result element is the default NaN.</li>
      </ul>
      To learn more about it, see <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489h/CIHDEEBE.html">here</a>.
    </li>
    <li>On x86 CPUs floating-point maximum works as follows:
      <ul>
        <li>If one of the source operands is NaN, than return the second source operand.</li>
        <li>If both source operands are equal to 0, than return the second source operand.</li>
      </ul>
      To learn more about it, see Volume 1 Appendix E chapter E.4.2.3 and Volume 2 at page 3-488 <a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf">here</a>.
    </li>
  </ul>
</li>
<li><code>VMIN/VMINQ</code><br/>
  If one of the operands is NaN or both are +/- 0.0 then
  <ul>
    <li>On ARM CPUs floating-point minimum works as follows:
      <ul>
        <li>min(+0.0, -0.0) = -0.0.</li>
        <li>If any input is a NaN, the corresponding result element is the default NaN.</li>
      </ul>
     To learn more about it, see <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489h/CIHDEEBE.html">here</a>.
    </li>
    <li>On x86 CPUs floating-point minimum works as follows:
      <ul>
        <li>If one of the source operands is NaN, than return the second source operand.</li>
        <li>If both source operands are equal to 0, than return the second source operand.</li>
      </ul>
      To learn more about it, see Volume 1 Appendix E chapter E.4.2.3 and Volume 2 at page 3-497 <a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf">here</a>.
    </li>
  </ul>
</li>
<li><code>VRECPE/VRECPEQ</code><br/>
  Different accuracy on ARM and x86 CPUs. To learn more about it, see ARM article "How do I use VRECPE/VRECPEQ for reciprocal estimate?" <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka14282.html">here</a>
  and Volume 2 at page 4-281 <a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf">here</a>.
</li>
<li><code>VRSQRTE/VRSQRTEQ</code><br/>
  <ul>
    <li>Different accuracy on ARM and x86 CPUs. To learn more about it, see <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204h/CIHCHECJ.html">here</a> and Volume 2 at page 4-325 <a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf">here</a>.</li>
    <li>If one of the operands is negative or -infinity then
      <ul>
        <li>On ARM CPUs function will return default NaN (sign is set to positive). To learn more about it, see <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489i/CIHIICBB.html">here</a>.</li>
        <li>On x86 CPUs function will return the QNaN floating-point Indefinite (sign is set to negative). To learn more about it, see Volume 1 Appendix E chapter E.4.2.3 <a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf">here</a>.</li>
      </ul>
    </li>
  </ul>
</li>
</ul>
<h3>Performance:</h3>
<p>For the major number of cases it is expected to obtain the similar to ARM NEON native perfomance gain for vectorized vs. serial code.</p>
<h3>Porting considerations and best known methods are:</h3>
<ul>
<li>Use 16-byte data alignment for faster load and store</li>
<li>Avoid NEON functions working with constants. It produces performance penalty for constants load. If constants usage is necessary try to move constants initialization out of hotspot loops and if applicable replace it with logical and compare operations.</li>
<li>Try to avoid functions marked as "serially implemented" because they need to store data from registers to memory, process them serialy and load them again. Probably you could change the data type or algorithm used to make the whole port vectorized not a serial one.</li>
</ul>
<p>To learn more about it, see <a href="http://software.intel.com/en-us/blogs/2012/12/12/from-arm-neon-to-intel-mmxsse-automatic-porting-solution-tips-and-tricks">here</a>.</p>
<h3>Sample code:</h3>
<p>In your project add 'x86' to APP_ABI definition and make sure "arm_neon.h" header is included. Your code will be ported to x86 without any other changes necessary.</p>
<p>Look at the "hello-neon" sample in NDK for an example on how ARM NEON porting to x86 SSE works.</p>
<h2>Standalone-toolchain</h2>
<p>It is possible to use the x86 toolchain with NDK r6 in stand-alone mode. See docs/STANDALONE-TOOLCHAIN.html for more details. Briefly speaking, it is now possible to run: </p>
<pre class="fragment">  $NDK/build/tools/make-standalone-toolchain.sh --arch=x86 --install-dir=&lt;path&gt;
</pre><p>The toolchain binaries have the <code>i686-linux-android- prefix</code>.</p>
<h2>Compatibility</h2>
<p>The minimal native API level provided by official Android x86 platform builds is 9, which corresponds to all the native APIs provided by Android 2.3, i.e. Gingerbread (note also that no new native APIs were introduced by Honeycomb).</p>
<p>You won't have to change anything to your project files if you target an older API level: the NDK build script will automatically select the right set of native platform headers/libraries for you. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jun 25 2014 00:51:19 for NDK Programmer&#39;s Guide by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
